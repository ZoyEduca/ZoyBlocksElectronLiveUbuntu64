<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Zoy Jogos - Labirinto com N√≠veis</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        // Configura√ß√£o do Tailwind para usar a fonte Inter e cores personalizadas
        tailwind.config = {
            theme: {
                extend: {
                    fontFamily: {
                        sans: ['Inter', 'sans-serif'],
                    },
                    colors: {
                        'zoy-blue': '#1e40af',
                        'zoy-dark': '#0f172a',
                        'zoy-light': '#f1f5f9',
                        'panda-color': '#34d399', 
                    }
                }
            }
        }
    </script>
    <link rel="stylesheet" href="../home/home.css"> 
    <style>
        /* Estilos espec√≠ficos para a tela de jogos */
        body, html { 
            height: 100%; 
            margin: 0; 
            padding: 0; 
            font-family: 'Inter', sans-serif; 
            background-color: #f0f4f8; 
          
        }
        
        /* Layout principal: 100% da viewport */
        #mainContainer { 
            display: flex; 
            flex-direction: column; 
            height: 100%; 
        }
        #gameAndBlockly { 
            display: flex; 
            flex-grow: 1; 
            overflow: hidden; 
          
        }

        /* √Årea do Jogo */
        #gameArea { 
            flex-basis: 40%; 
            max-width: 40%; 
            display: flex; 
            flex-direction: column; 
            align-items: center; 
            justify-content: flex-start; 
            padding: 20px; 
            overflow: auto; 
        }
        
        /* √Årea do Blockly */
        #blocklyArea { 
            flex-basis: 60%; 
            max-width: 60%; 
            height: 100%;
            border-left: 1px solid #e2e8f0;
        }
        #blocklyGameWorkspace { 
            width: 100%; 
            height: 100%; 
        }

         
        /* Responsividade para telas menores */
        @media (max-width: 1024px) {
            #gameAndBlockly {
                flex-direction: column; 
            }
            #gameArea, #blocklyArea {
                flex-basis: 100%;
                max-width: 100%;
                height: 50vh; 
            }
            #blocklyArea {
                border-left: none;
                border-top: 1px solid #e2e8f0;
            }
        
        }
        /* üöÄ CORRE√á√ÉO UNIFICADA: Esconde todas as barras de rolagem do Blockly */
        .blocklyWorkspace, .blocklyScrollbarHandle {
            overflow: hidden !important; /* J√° estava, mas refor√ßa */
        }
        .blocklyVScrollbar, 
        .blocklyHScrollbar, 
        .blocklyScrollbarVertical,
        .blocklyFlyoutScrollbar, /* Alvo Principal - Scrollbar da Caixa de Ferramentas */
        .blocklyScrollbarHandle { /* Alvo Anterior - O ret√¢ngulo que desliza */
            /* For√ßa a remo√ß√£o de todos os componentes de scrollbar */
            display: none !important;
        }
    </style>
</head>
<body>
    <div id="mainContainer">
        
        <div id="controls">
            <button 
                 class="mt-4 bg-yellow-500 hover:bg-yellow-600 text-white font-bold py-2 px-4 rounded-lg shadow-md transition duration-150 ease-in-out"
                 onclick="window.location.href='zoy_quiz.html'">
                 Ir para o Quiz
            </button>
            <button 
                class="bg-gray-400 hover:bg-gray-500 text-white font-bold py-2 px-4 rounded-lg shadow-md transition duration-150 ease-in-out" 
                id="btnVoltar" 
                onclick="window.electronAPI.goBack()">
                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-arrow-left-short inline-block mr-1" viewBox="0 0 16 16">
                    <path fill-rule="evenodd" d="M12 8a.5.5 0 0 1-.5.5H5.707l2.147 2.146a.5.5 0 0 1-.708.708l-3-3a.5.5 0 0 1 0-.708l3-3a.5.5 0 1 1 .708.708L5.707 7.5H11.5a.5.5 0 0 1 .5.5z"/>
                </svg>
                Voltar para Rob√≥tica
            </button>
            
            <button 
                class="bg-zoy-blue hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-lg shadow-md transition duration-150 ease-in-out" 
                id="btnExecutarPrograma" 
                onclick="window.executeProgram()">
                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-play-fill inline-block mr-1" viewBox="0 0 16 16">
                    <path d="m11.596 8.697-5.594 3.996c-.57.408-1.396-.039-1.396-.717V4.118c0-.678.825-1.125 1.396-.717l5.594 3.996a.9.9 0 0 1 0 1.314z"/>
                </svg>
                Executar Programa
            </button>
            <button 
                class="bg-red-500 hover:bg-red-700 text-white font-bold py-2 px-4 rounded-lg shadow-md transition duration-150 ease-in-out" 
                id="btnPararPrograma" 
                onclick="window.stopProgram()" 
                disabled>
                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-stop-fill inline-block mr-1" viewBox="0 0 16 16">
                    <path d="M5 3.5h6A1.5 1.5 0 0 1 12.5 5v6a1.5 1.5 0 0 1-1.5 1.5H5A1.5 1.5 0 0 1 3.5 11V5A1.5 1.5 0 0 1 5 3.5z"/>
                </svg>
                Parar
            </button>
            
            <label for="difficultySelector" class="text-sm font-medium text-gray-700">Fase:</label>
            <select id="difficultySelector" onchange="window.setDifficulty(this.value)"
                    class="py-2 px-3 border border-gray-300 rounded-lg shadow-sm focus:outline-none focus:ring-zoy-blue focus:border-zoy-blue sm:text-sm">
                <option value="easy">Fase 1: Movimento B√°sico (5x5)</option>
                <option value="medium">Fase 2: Curvas Simples (5x5)</option>
                <option value="hard">Fase 3: Labirinto Simples (7x7)</option>
                <option value="loop_challenge">Fase 4: Desafio de Repeti√ß√£o (5x5)</option>
                <option value="conditional_loop">Fase 5: Loop Condicional (7x7)</option>
                <option value="phase_6_turn_and_loop">Fase 6: Curvas Fechadas (5x5)</option>
                <option value="phase_7_conditional_path">Fase 7: Caminho Bifurcado (7x7)</option>
                <option value="phase_8_long_winding">Fase 8: Espiral Longa (7x7)</option>
                <option value="phase_9_double_loop">Fase 9: Desvio e Retorno (7x7)</option>
                <option value="phase_10_final_challenge">Fase 10: Desafio Final (8x8)</option>
            </select>

            <div id="statusMessage" class="px-3 py-1 rounded-lg text-sm bg-gray-100 text-gray-700 font-medium transition duration-150 ease-in-out">
                Pronto para come√ßar.
            </div>

            <pre id="generatedCodeDisplay">Nenhum bloco conectado</pre>
        </div>

        <div id="gameAndBlockly">
            <div id="gameArea">
                <h3 class="text-xl font-bold mb-4 text-zoy-dark">Labirinto do Rob√¥ Zoy</h3>
                <canvas id="gameCanvas" width="500" height="500"></canvas>
                <button 
                    class="mt-4 bg-green-500 hover:bg-green-700 text-white font-bold py-2 px-4 rounded-lg shadow-md transition duration-150 ease-in-out" 
                    onclick="window.resetGame()">
                    Reiniciar Labirinto
                </button>
            </div>

            <div id="blocklyArea">
                <div id="blocklyGameWorkspace"></div>
            </div>
        </div>
    </div>

    <xml id="toolboxMaze" style="display: none">
        <category name="Movimento" colour="#CC6666">
            <block type="maze_moveForward"></block>
            <block type="maze_turn"></block>
        </category>
        <category name="Controle" colour="#5CB85C">
            <block type="controls_repeat_simple"></block>
            <block type="controls_while_path"></block> 
            <block type="controls_if_path"></block>
            <block type="controls_if_else_path"></block>
        </category>
    </xml>

    <script src="zoy_jogos.js"></script>

    <script>
        // Vari√°veis Globais de Estado do Jogo (mantidas)
        let canvas, ctx;
        window.isRunning = false; 
        
        // 0=Parede, 1=Caminho, 2=In√≠cio (Rob√¥ Zoy), 3=Fim (Objetivo)
        
        // --- 1. DEFINI√á√ÉO DOS N√çVEIS DE DIFICULDADE (10 FASES) ---
        const MAZES = {
            // Fase 1: Movimento B√°sico
            easy: {
                size: 5,
                layout: [
                    [0, 0, 0, 0, 0], 
                    [0, 0, 0, 0, 0],
                    [2, 1, 1, 1, 3], 
                    [0, 0, 0, 0, 0],
                    [0, 0, 0, 0, 0] 
                ]
            },
            // Fase 2: Curvas Simples
            medium: {
                size: 5,
                layout: [
                    [2, 1, 0, 1, 1], 
                    [1, 1, 0, 0, 1],
                    [1, 0, 1, 1, 1],
                    [1, 0, 1, 0, 1],
                    [1, 1, 1, 0, 3]  
                ]
            },
            // Fase 3: Labirinto Simples
            hard: {
                size: 7,
                layout: [
                    [2, 1, 1, 0, 1, 1, 1], 
                    [0, 0, 1, 0, 1, 0, 1],
                    [1, 1, 1, 1, 1, 0, 1],
                    [1, 0, 0, 0, 1, 1, 1],
                    [1, 1, 1, 1, 0, 1, 0],
                    [0, 1, 0, 1, 0, 1, 1],
                    [1, 1, 0, 1, 1, 1, 3]
                ]
            },
            // Fase 4: Desafio de Repeti√ß√£o
            loop_challenge: {
                size: 5,
                layout: [
                    [2, 1, 0, 0, 0], 
                    [1, 1, 0, 0, 0],
                    [1, 0, 0, 0, 0],
                    [1, 0, 0, 0, 0],
                    [1, 1, 1, 1, 3]  
                ]
            },
            // Fase 5: Loop Condicional
            conditional_loop: {
                size: 7,
                layout: [
                    [2, 1, 1, 1, 1, 1, 0], 
                    [0, 0, 0, 0, 0, 1, 0],
                    [0, 1, 1, 1, 1, 1, 0],
                    [0, 1, 0, 0, 0, 0, 0],
                    [0, 1, 1, 1, 1, 1, 0],
                    [0, 0, 0, 0, 0, 1, 0],
                    [0, 1, 1, 1, 1, 1, 3] 
                ]
            },
            // --- NOVAS FASES (6 a 10) ---
            
            // Fase 6: Curvas Fechadas (Requer repeti√ß√£o e virar)
            phase_6_turn_and_loop: {
                size: 5,
                layout: [
                    [2, 1, 1, 1, 1],
                    [0, 0, 0, 0, 1],
                    [0, 0, 0, 0, 1],
                    [0, 0, 0, 0, 1],
                    [0, 0, 0, 0, 3]
                ]
            },
            // Fase 7: Caminho Bifurcado (Requer IF com virar)
            phase_7_conditional_path: {
                size: 7,
                layout: [
                    [2, 1, 1, 1, 0, 0, 0],
                    [0, 0, 0, 1, 1, 1, 0],
                    [0, 0, 0, 1, 0, 1, 0],
                    [0, 0, 0, 1, 0, 1, 0],
                    [0, 0, 0, 1, 0, 1, 0],
                    [0, 0, 0, 1, 1, 1, 3],
                    [0, 0, 0, 0, 0, 0, 0]
                ]
            },
            // Fase 8: Espiral Longa (Requer repeti√ß√£o e virar)
            phase_8_long_winding: {
                size: 7,
                layout: [
                    [2, 1, 1, 1, 1, 1, 0],
                    [0, 0, 0, 0, 0, 1, 0],
                    [1, 1, 1, 1, 0, 1, 0],
                    [1, 0, 0, 1, 0, 1, 0],
                    [1, 0, 0, 1, 0, 1, 1],
                    [1, 0, 0, 1, 0, 0, 1],
                    [1, 1, 1, 1, 1, 1, 3]
                ]
            },
            // Fase 9: Desvio e Retorno (Requer loop condicional)
            phase_9_double_loop: {
                size: 7,
                layout: [
                    [2, 1, 1, 0, 1, 1, 1],
                    [0, 0, 1, 0, 1, 0, 1],
                    [0, 0, 1, 0, 1, 0, 1],
                    [0, 0, 1, 1, 1, 0, 1],
                    [0, 0, 0, 0, 0, 0, 1],
                    [1, 1, 1, 1, 1, 1, 1],
                    [1, 0, 0, 0, 0, 0, 3]
                ]
            },
            // Fase 10: Desafio Final (8x8) (Combina√ß√£o de todos os blocos)
            phase_10_final_challenge: {
                size: 8,
                layout: [
                    [2, 1, 1, 1, 1, 1, 1, 0],
                    [0, 0, 0, 0, 0, 0, 1, 0],
                    [0, 1, 1, 1, 1, 0, 1, 0],
                    [0, 1, 0, 0, 1, 0, 1, 0],
                    [0, 1, 0, 0, 1, 1, 1, 0],
                    [0, 1, 0, 0, 0, 0, 0, 0],
                    [0, 1, 1, 1, 1, 1, 1, 3],
                    [0, 0, 0, 0, 0, 0, 0, 0]
                ]
            }
        };

        let currentDifficulty = 'easy';
        let MAZE_SIZE = MAZES[currentDifficulty].size;
        let MAZE = MAZES[currentDifficulty].layout;
        
        let currentPosition = { x: 0, y: 0 }; 
        let currentDirection = 0; // 0: Right, 1: Down, 2: Left, 3: Up

        // Refer√™ncia global para o elemento de status
        window.statusMessageElement = null; 
        
        // Cor do Rob√¥ (Zoy Blue)
        const ROBOT_COLOR = '#1e40af'; 
        const FACE_COLOR = '#ffffff';

        // --- FUN√á√ïES AUXILIARES DE ESTADO (mantidas) ---

        /** Fun√ß√£o para mudar a dificuldade e recarregar o labirinto. */
        window.setDifficulty = function(newDifficulty) {
            currentDifficulty = newDifficulty;
            const mazeConfig = MAZES[newDifficulty];
            
            if (!mazeConfig) {
                console.error(`Dificuldade desconhecida: ${newDifficulty}`);
                return;
            }
            
            MAZE = mazeConfig.layout;
            MAZE_SIZE = mazeConfig.size;
            window.resetGame(); // Reinicia o jogo com o novo labirinto
            
            // Redimensiona o workspace do Blockly ap√≥s a mudan√ßa de fase
            if (window.workspaceMaze) {
                Blockly.svgResize(window.workspaceMaze);
            }
            
            window.updateStatus(`Fase alterada para ${newDifficulty.toUpperCase()}.`);
        }


        /** Fun√ß√£o global para atualizar o status. */
        window.updateStatus = function(message, bgClass = 'bg-gray-100', textClass = 'text-gray-700') {
            if (!window.statusMessageElement) {
                console.error("ERRO DE DOM: Elemento statusMessage n√£o encontrado.");
                return;
            }
            window.statusMessageElement.className = `px-3 py-1 rounded-lg text-sm font-medium ${bgClass} ${textClass}`;
            window.statusMessageElement.textContent = message;
        }

        /** Fun√ß√£o de atraso (usada pelo c√≥digo Blockly gerado) */
        window.delay = (ms) => new Promise(resolve => setTimeout(resolve, ms));

        /** Reinicia o estado do jogo para a posi√ß√£o inicial. */
        window.resetGame = function() { 
            window.isRunning = false;
            // Encontra a posi√ß√£o inicial (tile 2)
            let foundStart = false;
            for (let y = 0; y < MAZE_SIZE; y++) {
                for (let x = 0; x < MAZE_SIZE; x++) {
                    if (MAZE[y][x] === 2) {
                        currentPosition = { x, y };
                        currentDirection = 0; // Dire√ß√£o inicial: Direita
                        foundStart = true;
                        break;
                    }
                }
                if (foundStart) break;
            }
            window.updateStatus('Labirinto Reiniciado. Pronto para programar!');
            drawMaze();
            // Garante que os bot√µes est√£o no estado correto
            document.getElementById('btnExecutarPrograma').disabled = false;
            document.getElementById('btnPararPrograma').disabled = true;
        }

        // --- FUN√á√ïES DE INTERA√á√ÉO DO JOGO (Chamadas pelo c√≥digo Blockly gerado) ---
        
        /** Move o Rob√¥ uma casa para frente. */
        window.moveForward = async function() {
            if (!window.isRunning) return false;
            
            await window.delay(300); 

            let newX = currentPosition.x;
            let newY = currentPosition.y;

            // 0: Right (+x), 1: Down (+y), 2: Left (-x), 3: Up (-y)
            switch (currentDirection) {
                case 0: newX++; break;
                case 1: newY++; break;
                case 2: newX--; break;
                case 3: newY--; break;
            }

            // 1. Verifica limites
            if (newX < 0 || newX >= MAZE_SIZE || newY < 0 || newY >= MAZE_SIZE) {
                window.updateStatus('Colis√£o com a borda do mapa!', 'bg-red-200', 'text-red-900');
                window.isRunning = false;
                throw new Error('Collision or Game Over');
            }

            const nextTile = MAZE[newY][newX];

            // 2. Verifica parede
            if (nextTile === 0) {
                window.updateStatus('Colis√£o com uma parede!', 'bg-red-200', 'text-red-900');
                window.isRunning = false;
                throw new Error('Collision or Game Over');
            }
            
            // 3. Move o Rob√¥
            currentPosition = { x: newX, y: newY };
            drawMaze();

            // 4. Verifica vit√≥ria (tile 3)
            if (nextTile === 3) {
                window.updateStatus('Parab√©ns! O Rob√¥ Zoy encontrou o Objetivo!', 'bg-green-200', 'text-green-800');
                window.isRunning = false;
                throw new Error('Game Over'); 
            }

            return true;
        };

        /** Vira o Rob√¥. */
        window.turn = async function(direction) {
            if (!window.isRunning) return false;
            
            await window.delay(300);

            if (direction === 'LEFT') {
                currentDirection = (currentDirection + 3) % 4; 
            } else { // 'RIGHT'
                currentDirection = (currentDirection + 1) % 4; 
            }
            drawMaze();
            return true;
        };

        /** Verifica se h√° caminho livre na dire√ß√£o especificada. */
        window.isPath = function(checkDirection) {
            let dir = currentDirection;
            
            if (checkDirection === 'LEFT') {
                dir = (currentDirection + 3) % 4;
            } else if (checkDirection === 'RIGHT') {
                dir = (currentDirection + 1) % 4;
            } else if (checkDirection === 'FORWARD') {
                // Usa a dire√ß√£o atual
            }
            
            let checkX = currentPosition.x;
            let checkY = currentPosition.y;

            // 0: Right (+x), 1: Down (+y), 2: Left (-x), 3: Up (-y)
            switch (dir) {
                case 0: checkX++; break; 
                case 1: checkY++; break; 
                case 2: checkX--; break; 
                case 3: checkY--; break; 
            }

            // Verifica limites e paredes
            if (checkX < 0 || checkX >= MAZE_SIZE || checkY < 0 || checkY >= MAZE_SIZE) {
                return false; 
            }
            
            return MAZE[checkY][checkX] !== 0; 
        };
        
        // --- L√ìGICA DE DESENHO (Canvas) e L√ìGICA DE CONTROLE DE C√ìDIGO (Interface com Blockly) ---
        
        /**
         * Desenha o Rob√¥ Zoy estilizado no canvas.
         */
        function drawZoyRobot(x, y, tileSize, direction) {
            const centerX = x * tileSize + tileSize / 2;
            const centerY = y * tileSize + tileSize / 2;
            const robotSize = tileSize * 0.7;
            const bodySize = robotSize * 0.7;
            const headRadius = robotSize * 0.25;

            ctx.save();
            ctx.translate(centerX, centerY);
            // Rotaciona: 0=Right (0 rad), 1=Down (PI/2), 2=Left (PI), 3=Up (3PI/2)
            ctx.rotate(direction * Math.PI / 2); 

            // 1. Corpo (Zoy Blue)
            ctx.fillStyle = ROBOT_COLOR;
            ctx.fillRect(-bodySize / 2, -bodySize / 2, bodySize, bodySize);
            
            // 2. Cabe√ßa/Face (Branco) - Deslocada para frente (dire√ß√£o 0)
            const headOffset = bodySize / 2;
            ctx.fillStyle = FACE_COLOR;
            ctx.beginPath();
            ctx.arc(headOffset + headRadius * 0.2, 0, headRadius, 0, Math.PI * 2);
            ctx.fill();

            // 3. Antenas/Indicador de Dire√ß√£o (Zoy Dark)
            ctx.fillStyle = '#0f172a';
            const antennaLength = robotSize * 0.3;
            const antennaWidth = robotSize * 0.08;

            // Antena Superior
            ctx.fillRect(headOffset + headRadius * 0.2, -headRadius - antennaLength, antennaWidth, antennaLength);
            // Antena Inferior
            ctx.fillRect(headOffset + headRadius * 0.2, headRadius, antennaWidth, antennaLength);


            ctx.restore();
        }


        function drawMaze() {
            if (!ctx) return;

            const canvasSize = Math.min(canvas.width, canvas.height);
            // MAZE_SIZE √© din√¢mico agora (5 ou 7)
            const tileSize = canvasSize / MAZE_SIZE; 
            
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // 1. Desenha as c√©lulas do labirinto
            for (let y = 0; y < MAZE_SIZE; y++) {
                for (let x = 0; x < MAZE_SIZE; x++) {
                    const tile = MAZE[y][x];
                    
                    ctx.fillStyle = (tile === 0) ? '#475569' : '#e2e8f0'; // Parede vs Caminho 
                    if (tile === 3) {
                        ctx.fillStyle = '#fcd34d'; // Fim (Objetivo - Amarelo)
                        // Desenha um alvo ou algo para o objetivo
                        ctx.beginPath();
                        ctx.arc(x * tileSize + tileSize / 2, y * tileSize + tileSize / 2, tileSize * 0.3, 0, Math.PI * 2);
                        ctx.fillStyle = '#cc8c00';
                        ctx.fill();
                        ctx.strokeStyle = '#fff';
                        ctx.lineWidth = 3;
                        ctx.stroke();

                    } else if (tile === 2) {
                        ctx.fillStyle = '#bbf7d0'; // In√≠cio (Verde claro)
                    }
                    
                    ctx.fillRect(x * tileSize, y * tileSize, tileSize, tileSize);
                    ctx.strokeStyle = '#94a3b8';
                    ctx.strokeRect(x * tileSize, y * tileSize, tileSize, tileSize);
                }
            }

            // 2. Desenha o Rob√¥ Zoy (no lugar do Panda)
            drawZoyRobot(currentPosition.x, currentPosition.y, tileSize, currentDirection);
        }

        // --- L√ìGICA DE CONTROLE DE C√ìDIGO (Interface com Blockly) (mantida) ---
        
        /** * Gera o c√≥digo a partir do workspace do Blockly e atualiza o painel de exibi√ß√£o. */
        window.updateCodeDisplay = function() {
            if (!window.Blockly || !window.workspaceMaze) return;

            const code = window.jsGenerator.workspaceToCode(window.workspaceMaze);
            
            const finalCode = `(async function() {\n${code}})();`;
            
            const displayElement = document.getElementById('generatedCodeDisplay');
            
            if (displayElement) {
                displayElement.textContent = finalCode;
            }
            return finalCode;
        };
        
        /** * Inicia a execu√ß√£o do programa Blockly. */
        window.executeProgram = async function() {
            if (window.isRunning) return; 
            
            if (typeof window.executeProgramInJS === 'function') {
                return window.executeProgramInJS();
            }
            
            const code = window.updateCodeDisplay(); 
            
            if (!code || code.includes("Nenhum bloco conectado")) {
                window.updateStatus("Conecte os blocos para criar um programa.", 'bg-yellow-200', 'text-yellow-800');
                return;
            }
            
            window.resetGame(); 
            window.isRunning = true;
            window.updateStatus('Executando programa...', 'bg-blue-200', 'text-blue-800');
            
            document.getElementById('btnExecutarPrograma').disabled = true;
            document.getElementById('btnPararPrograma').disabled = false;

            try {
                await eval(code); 
            } catch (e) {
                if (e.message !== 'Collision or Game Over' && e.message !== 'Game Over') {
                    window.updateStatus(`ERRO DE EXECU√á√ÉO: ${e.message}`, 'bg-red-200', 'text-red-900');
                    console.error("Erro na execu√ß√£o do programa Blockly:", e);
                }
            } finally {
                if (window.isRunning) { 
                    window.updateStatus('Programa Terminado. Reinicie para tentar novamente.', 'bg-gray-200', 'text-gray-700');
                }
                window.isRunning = false;
                document.getElementById('btnExecutarPrograma').disabled = false;
                document.getElementById('btnPararPrograma').disabled = true;
            }
        }
        
        /** * Fun√ß√£o para parar a execu√ß√£o pelo usu√°rio. */
        window.stopProgram = function() {
            window.isRunning = false; 
            window.updateStatus("Execu√ß√£o interrompida pelo usu√°rio.", 'bg-gray-200', 'text-gray-700');
            document.getElementById('btnExecutarPrograma').disabled = false;
            document.getElementById('btnPararPrograma').disabled = true;
        };


        // --- INICIALIZA√á√ÉO E REDIMENSIONAMENTO (mantidas) ---

        function resizeCanvas() {
            const container = document.getElementById('gameArea');
            if (!container || !canvas) return;
            
            // Garante que o canvas seja quadrado e se ajuste √† √°rea
            const size = Math.min(container.clientWidth * 0.9, window.innerHeight * 0.8);
            canvas.width = size;
            canvas.height = size;
            drawMaze();
        }

        function initGameEnvironment() {
            canvas = document.getElementById('gameCanvas');
            
            if (!canvas) {
                 console.error("Canvas n√£o encontrado.");
                 return;
            }
            
            ctx = canvas.getContext('2d');
            // Inicializa a refer√™ncia global do elemento de status.
            window.statusMessageElement = document.getElementById('statusMessage');
            
            window.addEventListener('resize', resizeCanvas);
            
            // Define a dificuldade inicial (padr√£o 'easy')
            window.setDifficulty(document.getElementById('difficultySelector').value); 
            resizeCanvas();
        }

        document.addEventListener("DOMContentLoaded", initGameEnvironment);
    </script>
</body>
</html>